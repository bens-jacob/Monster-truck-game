<!doctype html>
<html lang="en">
<head>
  <!--
    Brent's Monster Race — Single-file HTML5 Game
    How to play:
      • Mobile: Brake = left big button. Jump = right bottom. Boost = right above Jump. Pause = top-right. Mute = top-left.
      • Desktop: A = brake, Space = jump, Shift = boost, P/Esc = pause, R = restart, M = mute.
    Modes:
      • 3 Laps or 60s Time Trial. Choose on the start screen.
    Tuning:
      • Edit SETTINGS at the top of the script: SPEED, JUMP_POWER, GRAVITY, BOOST_MULTIPLIER, LAP_COUNT, TIME_LIMIT_SEC.
    Notes:
      • No external libraries. Offline-ready. Pixel-art look via low-res canvas upscaling.
  -->
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <title>Brent's Monster Race</title>
  <style>
    :root{
      --ui-bg: rgba(20,20,30,0.5);
      --ui-fg: #fff;
      --accent: #ffd400;
      --green: #28cf6a;
      --red: #ff3b30;
      --blue: #007aff;
      --black: #0a0a0a;
    }
    html, body {
      height: 100%;
      margin: 0;
      background: #1b1f2a;
      color: var(--ui-fg);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
      touch-action: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #wrap{
      position: fixed; inset: 0; display: grid; place-items: center;
    }
    /* Visible display canvas that scales the low-res buffer with pixelated look */
    #view {
      width: 100vw; height: 100vh;
      image-rendering: pixelated;
      image-rendering: crisp-edges;
      background: #87ceeb; /* sky fallback during load */
      display: block;
    }
    /* Overlay UI */
    .overlay {
      position: fixed; inset: 0; pointer-events: none;
      font-size: 14px;
    }
    .hud {
      position: absolute; left: 8px; top: 8px; pointer-events: none;
      background: var(--ui-bg); padding: 6px 8px; border-radius: 8px;
      display: grid; gap: 4px; align-content: start;
    }
    .row { display: flex; gap: 8px; align-items: center; }
    .label { opacity: 0.9; }
    .val { font-weight: 700; color: var(--accent); }
    .bar { width: 160px; height: 10px; background: rgba(255,255,255,0.15); border-radius: 6px; overflow: hidden; }
    .fill { height: 100%; width: 0%; background: #ff9800; transition: width 0.08s linear; }

    /* Top-right buttons */
    .top-right {
      position: absolute; right: 8px; top: 8px; display: flex; gap: 8px;
    }
    .chip {
      pointer-events: auto;
      background: var(--ui-bg);
      border: 1px solid rgba(255,255,255,0.2);
      padding: 8px 10px; border-radius: 10px;
      font-weight: 700;
    }

    /* Mobile controls */
    .controls {
      position: absolute; inset: 0; pointer-events: none;
    }
    .btn {
      position: absolute;
      width: 96px; height: 96px; border-radius: 16px;
      background: rgba(30,30,40,0.45);
      border: 2px solid rgba(255,255,255,0.35);
      color: white; font-weight: 800;
      display: grid; place-items: center;
      pointer-events: auto;
      -webkit-tap-highlight-color: transparent;
      touch-action: none;
    }
    .btn span { font-size: 14px; opacity: 0.95; }
    #btnBrake { left: 16px; bottom: 24px; }
    #btnJump  { right: 16px; bottom: 24px; }
    #btnBoost { right: 16px; bottom: 128px; }

    /* Start screen */
    .start {
      position: fixed; inset: 0; display: grid; place-content: center; gap: 16px;
      background: linear-gradient(#1a1d28, #10131a);
      padding: 20px;
    }
    .card {
      background: rgba(255,255,255,0.06);
      border: 1px solid rgba(255,255,255,0.18);
      border-radius: 16px;
      padding: 12px;
    }
    .title {
      font-size: 28px; font-weight: 900; text-align: center; letter-spacing: 0.5px;
    }
    .subtitle { text-align: center; opacity: 0.9; }
    .grid {
      display: grid; grid-template-columns: repeat(3, 1fr); gap: 12px; margin-top: 8px;
    }
    .truck {
      cursor: pointer; border-radius: 12px; padding: 8px; text-align: center;
      border: 2px solid transparent; background: rgba(0,0,0,0.25);
    }
    .truck.selected { border-color: var(--accent); background: rgba(255,212,0,0.15); }
    .truck canvas { display:block; margin: 0 auto; image-rendering: pixelated; }
    .modes { display:flex; gap:12px; justify-content:center; align-items:center; margin-top: 8px; }
    .start-actions { display:flex; gap:12px; justify-content:center; margin-top: 8px; }
    .btnStart {
      padding: 10px 18px; border-radius: 12px; border: 0;
      font-weight: 800; color: #000; background: var(--accent); cursor: pointer;
    }
    .muted { opacity: 0.6; }
    .finish {
      position: fixed; inset: 0; display: none; place-content: center; text-align: center; gap: 12px;
      background: rgba(0,0,0,0.65);
      padding: 20px;
    }
    .finish .panel {
      background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.25);
      border-radius: 16px; padding: 16px 20px;
    }
    .finish h1 { margin: 0 0 8px 0; }
    .finish button {
      margin-top: 8px; padding: 10px 16px; border-radius: 12px; border: 0; font-weight: 800;
      background: var(--accent); color: #000; cursor: pointer;
    }

    @media (min-width: 900px) {
      .btn { width: 108px; height: 108px; }
      #btnBoost { bottom: 140px; }
    }
  </style>
</head>
<body>
  <div id="wrap">
    <canvas id="view" width="480" height="270"></canvas>
    <div class="overlay">
      <div class="hud card" id="hud">
        <div class="row"><span class="label">Mode:</span><span class="val" id="hudMode">—</span></div>
        <div class="row"><span class="label" id="hudLapLabel">Lap</span>: <span class="val" id="hudLap">0/3</span></div>
        <div class="row"><span class="label">Time:</span><span class="val" id="hudTime">0.0s</span></div>
        <div class="row"><span class="label">Coins:</span><span class="val" id="hudCoins">0</span></div>
        <div class="row" style="align-items:center;">
          <span class="label">Boost</span>
          <div class="bar"><div class="fill" id="boostFill"></div></div>
        </div>
      </div>

      <div class="top-right">
        <button id="btnPause" class="chip">Pause</button>
        <button id="btnMute"  class="chip">Mute</button>
      </div>

      <div class="controls">
        <div class="btn" id="btnBrake"><span>Brake</span></div>
        <div class="btn" id="btnJump"><span>Jump</span></div>
        <div class="btn" id="btnBoost"><span>Boost</span></div>
      </div>
    </div>

    <div class="start" id="startScreen">
      <div class="title">Brent's Monster Race</div>
      <div class="subtitle">Choose your monster ride and mode</div>
      <div class="grid" id="truckGrid"></div>
      <div class="modes card">
        <label><input type="radio" name="mode" value="laps" checked> 3 Laps</label>
        <label><input type="radio" name="mode" value="time"> 60s Time Trial</label>
      </div>
      <div class="start-actions">
        <button class="btnStart" id="btnStart">Start</button>
      </div>
      <div style="text-align:center; font-size:12px; opacity:0.8; margin-top:6px;">
        Desktop: A=Brake, Space=Jump, Shift=Boost, P/Esc=Pause, R=Restart, M=Mute
      </div>
    </div>

    <div class="finish" id="finishScreen">
      <div class="panel">
        <h1 id="finishTitle">Great job, Brent!</h1>
        <div id="finishStats"></div>
        <div style="margin-top:6px; font-size: 12px; opacity:0.85;" id="finishPB"></div>
        <button id="btnRestart">Restart</button>
      </div>
    </div>
  </div>

<script>
'use strict';

/* ================= SETTINGS ================= */
const SETTINGS = {
  SPEED: 42,             // base forward speed in px/s in world units
  MAX_SPEED: 72,
  BRAKE_DECEL: 80,
  ACCEL: 28,
  JUMP_POWER: 220,
  GRAVITY: 560,
  BOOST_MULTIPLIER: 1.6,
  BOOST_DRAIN_PER_S: 0.5,     // fraction per second
  BOOST_REFILL_PICKUP: 0.35,  // fraction per booster pickup
  LAP_COUNT: 3,
  TIME_LIMIT_SEC: 60,
  TRACK_LENGTH: 2200,     // world units per lap
  COIN_COUNT: 26,
  OBSTACLE_COUNT: 10,
  BOOSTER_COUNT: 6,
  CAMERA_LERP: 0.12,
  SHAKE_MAX: 4,
  PIXEL_W: 480, PIXEL_H: 270 // internal render resolution
};

/* ============== GLOBAL STATE ============== */
const canvas = document.getElementById('view');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = false;

let off = document.createElement('canvas');
off.width = SETTINGS.PIXEL_W; off.height = SETTINGS.PIXEL_H;
let octx = off.getContext('2d');
octx.imageSmoothingEnabled = false;

let last = performance.now();
let acc = 0;

let gameState = 'menu'; // menu | running | paused | finished
let input = { left:false, brake:false, jump:false, boost:false };
let mobileHold = { brake:false, jump:false, boost:false };
let muted = false;
let mode = 'laps';
let playerName = 'Brent';

const trucks = [
  { id:'lambo', name:'Red Monster Lamborghini', color:'#ff3b30', wheels:'#1a1a1a', flame:true, lights:false, accel:1.0, top:1.0 },
  { id:'offroad', name:'Black Monster Off-Road', color:'#222', wheels:'#0a0a0a', flame:false, lights:true, accel:1.05, top:0.95 },
  { id:'race', name:'Green Monster Race Car', color:'#2ecc71', wheels:'#123d22', flame:false, lights:false, accel:1.1, top:1.05 }
];
let selectedTruck = trucks[0];

/* ============== UTILS ============== */
const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
const lerp = (a,b,t)=>a+(b-a)*t;
function randRange(a,b){ return a + Math.random()*(b-a); }
function seededRand(seed){ // simple LCG for deterministic track item layout
  let s = seed % 2147483647; if (s <= 0) s += 2147483646;
  return ()=> (s = s * 16807 % 2147483647) / 2147483647;
}
function formatTime(t){
  const s = Math.max(0,t);
  return s.toFixed(1)+'s';
}

/* ============== AUDIO ============== */
const AudioSys = (()=>{
  let actx = null;
  const ensure = ()=>{
    if (!actx) {
      const AudioCtx = window.AudioContext || window.webkitAudioContext;
      actx = new AudioCtx();
    }
    return actx;
  };
  function beep(freq=700, dur=0.12, type='sine', vol=0.2){
    if (muted) return;
    const ac = ensure();
    const o = ac.createOscillator();
    const g = ac.createGain();
    o.type = type; o.frequency.value = freq;
    g.gain.value = vol;
    o.connect(g).connect(ac.destination);
    const t = ac.currentTime;
    o.start(t);
    g.gain.exponentialRampToValueAtTime(0.0001, t+dur);
    o.stop(t+dur);
  }
  function coin(){ beep(900,0.08,'square',0.18); setTimeout(()=>beep(1200,0.06,'square',0.18),30); }
  function jump(){ beep(500,0.12,'triangle',0.2); }
  function land(){ beep(220,0.07,'sine',0.12); }
  function boost(){ beep(300,0.18,'sawtooth',0.16); }
  function slow(){ beep(160,0.12,'sine',0.12); }
  return {beep, coin, jump, land, boost, slow, ensure};
})();

/* ============== TRACK ============== */
function trackHeight(x){
  // Gentle rolling hills using a few sine waves
  return 150 + Math.sin(x*0.003)*18 + Math.sin(x*0.0016+1.3)*12 + Math.sin(x*0.006+2.1)*6;
}
function trackSlope(x){
  // derivative approximation for tilt and normal
  const dx = 2;
  const h1 = trackHeight(x-dx), h2 = trackHeight(x+dx);
  return (h2 - h1)/(dx*2);
}

/* ============== WORLD OBJECTS ============== */
let world = {
  lapLen: SETTINGS.TRACK_LENGTH,
  items: [],    // coins
  obstacles: [],// cones/boxes
  boosters: [], // boost refills
  seed: 1337
};
function placeWorld(seed){
  world.items = [];
  world.obstacles = [];
  world.boosters = [];
  const rand = seededRand(seed);
  // Place coins
  for(let i=0;i<SETTINGS.COIN_COUNT;i++){
    const x = (i+1) * (world.lapLen/(SETTINGS.COIN_COUNT+1)) + randRange(-30,30);
    const y = trackHeight(x) - 22 - (i%2?8:0);
    world.items.push({x,y, got:false});
  }
  // Place obstacles
  for(let i=0;i<SETTINGS.OBSTACLE_COUNT;i++){
    const x = rand() * (world.lapLen-200) + 120;
    const y = trackHeight(x);
    world.obstacles.push({x,y,type: (i%2?'cone':'box'), hit:false});
  }
  // Place boosters
  for(let i=0;i<SETTINGS.BOOSTER_COUNT;i++){
    const x = rand() * (world.lapLen-200) + 100;
    const y = trackHeight(x) - 18;
    world.boosters.push({x,y, got:false});
  }
}

/* ============== PLAYER ============== */
let player = {
  x: 50, y: 0, vy: 0, rot: 0, onGround: false,
  speed: SETTINGS.SPEED,
  coins: 0,
  lap: 1,
  boost: 0.6, // fraction 0..1
  boosting: false,
  bestTime: null, bestCoins: 0,
  time: 0,
  landed: true
};

function resetPlayer(){
  player.x = 50; player.y = trackHeight(player.x)-26; player.vy = 0; player.rot = 0;
  player.onGround = true; player.speed = SETTINGS.SPEED; player.coins = 0; player.lap = 1;
  player.boost = 0.6; player.boosting = false; player.time = 0; player.landed = true;
  camera.x = 0; camera.y = 0; camera.tx = 0; camera.ty = 0; shake.time = 0;
}

function storageKey(truckId){ return `bmr_pb_${truckId}`; }
function loadPB(truckId){
  try{
    const raw = localStorage.getItem(storageKey(truckId));
    if (raw){
      const d = JSON.parse(raw);
      return d;
    }
  }catch(_){}
  return { bestTimeLaps: null, bestCoinsLaps: 0, bestCoinsTime: 0 };
}
function savePB(truckId, data){
  try{ localStorage.setItem(storageKey(truckId), JSON.stringify(data)); }catch(_){}
}

/* ============== CAMERA & SHAKE ============== */
let camera = { x:0, y:0, tx:0, ty:0 };
let shake = { time:0, mag:0 };
function doShake(mag=2, dur=120){
  shake.time = dur; shake.mag = mag;
}

/* ============== RENDERING ============== */
function clearCanvas(){
  octx.fillStyle = '#5db3ff'; // sky
  octx.fillRect(0,0,off.width, off.height);
  // parallax layers as pixel hills
  const w = off.width, h = off.height;
  // Far mountains
  octx.fillStyle = '#7cc6ff';
  for(let x=0;x<w;x+=2){
    const y = Math.sin((x+camera.x*0.1)*0.01)*4 + 160;
    octx.fillRect(x, y-60, 2, 60);
  }
  // Mid hills
  octx.fillStyle = '#6bbf5b';
  for(let x=0;x<w;x+=2){
    const y = Math.sin((x+camera.x*0.2)*0.02)*6 + 180;
    octx.fillRect(x, y-40, 2, 40);
  }
}

function drawGround(){
  const w = off.width, h = off.height;
  const startX = camera.x - 20;
  const endX = camera.x + w + 20;
  octx.fillStyle = '#3e7f2a';
  for(let sx = Math.floor(startX); sx < endX; sx+=2){
    const th = trackHeight(sx);
    const sy = Math.floor(th - camera.y);
    octx.fillRect(Math.floor(sx - camera.x), sy, 2, h-sy);
  }
  // road line
  octx.fillStyle = '#6a4a2b';
  for(let sx = Math.floor(startX); sx < endX; sx+=2){
    const th = trackHeight(sx)-6;
    const sy = Math.floor(th - camera.y);
    octx.fillRect(Math.floor(sx - camera.x), sy, 2, 4);
  }
}

function drawWheel(cx, cy, r, color, highlight='#555'){
  // large pixelated wheel
  octx.fillStyle = color;
  octx.beginPath();
  octx.arc(Math.round(cx), Math.round(cy), r, 0, Math.PI*2);
  octx.fill();
  // hub
  octx.fillStyle = highlight;
  octx.beginPath();
  octx.arc(Math.round(cx), Math.round(cy), r*0.35, 0, Math.PI*2);
  octx.fill();
}

function drawFlames(x, y, len=10){
  // simple pixel flames to the back
  octx.fillStyle = '#ffa500';
  octx.fillRect(x-2, y-3, len, 3);
  octx.fillStyle = '#ffea00';
  octx.fillRect(x-2, y-2, len*0.6, 1);
  octx.fillStyle = '#ff5a00';
  octx.fillRect(x-2, y-1, len*0.9, 1);
}

function drawTruck(type, x, y, rot){
  // Draw wheels
  const R = 14; // wheel radius
  const baseY = y;
  const ax = x-22, bx = x+22, wy = baseY+8;
  drawWheel(ax, wy, R, type.wheels);
  drawWheel(bx, wy, R, type.wheels);

  // Body
  octx.save();
  octx.translate(x, baseY);
  octx.rotate(rot*0.2);
  // Chassis
  octx.fillStyle = '#222';
  octx.fillRect(-26, -2, 52, 6);

  // Body styles
  octx.fillStyle = type.color;

  if (type.id === 'lambo'){
    // Low wedge shape Lamborghini
    octx.fillRect(-24, -14, 50, 12);
    octx.clearRect(18, -12, 10, 6); // rear cut
    // cabin
    octx.fillStyle = '#333';
    octx.fillRect(-6, -18, 18, 8);
    // flame decals
    octx.fillStyle = '#ffcf33';
    octx.fillRect(-10, -8, 10, 2);
    octx.fillStyle = '#ff7b00';
    octx.fillRect(2, -8, 8, 2);
    // boosters when boosting
    if (player.boosting){
      drawFlames(x-26, baseY-8, 14);
    }
  } else if (type.id === 'offroad'){
    // Boxy truck with roof lights
    octx.fillRect(-28, -16, 44, 14);
    octx.fillRect(10, -12, 16, 10); // rear box
    // cabin window
    octx.fillStyle = '#2f5b79';
    octx.fillRect(-16, -14, 14, 6);
    // roof lights
    octx.fillStyle = '#ffe066';
    for(let i=-14;i<=6;i+=10){ octx.fillRect(i, -20, 4, 4); }
  } else {
    // Green race car style
    octx.fillRect(-26, -12, 54, 10);
    octx.fillStyle = '#1a9b56';
    octx.fillRect(-6, -16, 16, 6); // cockpit
    // rear wing
    octx.fillStyle = type.color;
    octx.fillRect(18, -14, 10, 2);
  }
  octx.restore();

  // Speed lines when boosting
  if (player.boosting){
    octx.fillStyle = 'rgba(255,255,255,0.5)';
    for(let i=0;i<3;i++){
      const lx = Math.floor(x - 50 - i*12 + (Math.random()*6));
      const ly = Math.floor(y - 12 + Math.random()*24);
      octx.fillRect(lx, ly, 8, 1);
    }
  }
}

function drawCoin(x,y){
  octx.fillStyle = '#ffd400';
  octx.fillRect(x-3,y-6,6,12);
  octx.fillStyle = '#ffea84';
  octx.fillRect(x-1,y-4,2,8);
  octx.strokeStyle = '#7a5200';
  octx.strokeRect(x-3.5,y-6.5,7,13);
}

function drawBooster(x,y){
  octx.fillStyle = '#ff5a00';
  octx.fillRect(x-6,y-6,12,12);
  octx.fillStyle = '#ffee00';
  octx.fillRect(x-2,y-2,4,4);
}

function drawObstacle(o){
  if (o.type==='cone'){
    octx.fillStyle = '#ff7b00';
    octx.fillRect(o.x-6 - camera.x, o.y-10 - camera.y, 12, 10);
    octx.fillStyle = '#fff';
    octx.fillRect(o.x-6 - camera.x, o.y-5 - camera.y, 12, 2);
  } else {
    octx.fillStyle = '#8b5a2b';
    octx.fillRect(o.x-8 - camera.x, o.y-12 - camera.y, 16, 12);
  }
}

/* ============== GAME LOOP ============== */
function step(dt){
  if (gameState!=='running') return;
  // physics
  const truckTop = selectedTruck.top || 1.0;
  const truckAccel = selectedTruck.accel || 1.0;

  // base acceleration
  player.speed = lerp(player.speed, SETTINGS.SPEED*truckTop, Math.min(1, dt*0.7));
  if (input.brake) {
    player.speed = Math.max(12, player.speed - SETTINGS.BRAKE_DECEL*dt);
  } else {
    player.speed = Math.min(SETTINGS.MAX_SPEED*truckTop, player.speed + SETTINGS.ACCEL*dt*truckAccel);
  }

  // Boost
  if (input.boost && player.boost>0.01){
    player.boosting = true;
    player.speed = Math.min(SETTINGS.MAX_SPEED*truckTop, player.speed * SETTINGS.BOOST_MULTIPLIER);
    player.boost = clamp(player.boost - SETTINGS.BOOST_DRAIN_PER_S*dt, 0, 1);
  } else {
    player.boosting = false;
  }

  // Integrate horizontal
  player.x += player.speed * dt;

  // Laps
  if (player.x >= world.lapLen*player.lap){
    if (mode==='laps'){
      if (player.lap >= SETTINGS.LAP_COUNT){
        finishRun();
      } else {
        player.lap++;
        AudioSys.beep(800,0.08,'square',0.2);
      }
    } else {
      // time trial wraps but continues timing
      player.lap++;
      AudioSys.beep(800,0.06,'triangle',0.15);
    }
  }

  // Gravity and vertical
  player.vy += SETTINGS.GRAVITY * dt;
  let ground = trackHeight(player.x);
  if (player.y + player.vy*dt >= ground-26){
    // land
    if (!player.onGround) { AudioSys.land(); doShake(SETTINGS.SHAKE_MAX, 90); }
    player.y = ground-26; player.vy = 0; player.onGround = true; player.landed = true;
  } else {
    player.y += player.vy*dt; player.onGround = false;
  }

  // Jump
  if (input.jump && player.onGround){
    player.vy = -SETTINGS.JUMP_POWER;
    player.onGround = false; player.landed = false;
    AudioSys.jump();
  }

  // Tilt tends toward slope
  const slope = trackSlope(player.x);
  player.rot = lerp(player.rot, slope, 0.15);

  // Collisions with items
  for (const c of world.items){
    if (!c.got){
      const dx = (c.x - player.x);
      if (dx>-30 && dx<30){
        const dy = (c.y - player.y);
        if (Math.abs(dx) < 14 && Math.abs(dy) < 18){
          c.got = true; player.coins++; AudioSys.coin();
        }
      }
    }
  }
  // Collisions with boosters
  for (const b of world.boosters){
    if (!b.got){
      const dx = (b.x - player.x);
      if (Math.abs(dx) < 16 && Math.abs((b.y - player.y)) < 20){
        b.got = true; player.boost = clamp(player.boost + SETTINGS.BOOST_REFILL_PICKUP, 0, 1);
        AudioSys.boost();
      }
    }
  }
  // Obstacles slow
  for (const o of world.obstacles){
    if (!o.hit){
      const dx = (o.x - player.x);
      if (Math.abs(dx) < 18 && Math.abs((o.y - player.y)) < 22){
        o.hit = true;
        player.speed = Math.max(18, player.speed*0.6);
        doShake(SETTINGS.SHAKE_MAX, 140);
        AudioSys.slow();
      }
    }
  }

  // Timer
  player.time += dt;
  if (mode==='time' && player.time >= SETTINGS.TIME_LIMIT_SEC){
    finishRun();
  }

  // Camera target
  camera.tx = player.x - 140;
  camera.ty = player.y - 120;
  camera.x = lerp(camera.x, camera.tx, SETTINGS.CAMERA_LERP);
  camera.y = lerp(camera.y, camera.ty, SETTINGS.CAMERA_LERP);

  // Screen shake offset
  if (shake.time > 0){
    shake.time -= dt*1000;
  }
}

function render(){
  clearCanvas();
  drawGround();

  // Draw world items
  for (const c of world.items){
    if (c.got) continue;
    drawCoin(c.x - camera.x, c.y - camera.y);
  }
  for (const b of world.boosters){
    if (b.got) continue;
    drawBooster(b.x - camera.x, b.y - camera.y);
  }
  for (const o of world.obstacles){
    if (o.x > camera.x-40 && o.x < camera.x + off.width + 40){
      drawObstacle(o);
    }
  }

  // Draw player
  drawTruck(selectedTruck, player.x - camera.x, player.y - camera.y, player.rot);

  // Apply shake and blit to visible canvas
  const sx = shake.time>0 ? (Math.random()*2-1)*shake.mag : 0;
  const sy = shake.time>0 ? (Math.random()*2-1)*shake.mag : 0;

  ctx.imageSmoothingEnabled = false;
  ctx.clearRect(0,0,canvas.width, canvas.height);
  ctx.drawImage(off, Math.floor(sx), Math.floor(sy), off.width, off.height,
                     0, 0, canvas.width, canvas.height);
}

function loop(ts){
  const dt = Math.min(0.033, (ts - last)/1000); // cap 30ms
  last = ts;
  if (gameState==='running') step(dt);
  render();

  // HUD update
  if (gameState!=='menu'){
    document.getElementById('hudTime').textContent = formatTime(player.time);
    document.getElementById('hudCoins').textContent = player.coins;
    document.getElementById('hudLap').textContent = `${Math.min(player.lap, SETTINGS.LAP_COUNT)}/${SETTINGS.LAP_COUNT}`;
    document.getElementById('boostFill').style.width = `${Math.floor(player.boost*100)}%`;
  }
  requestAnimationFrame(loop);
}

/* ============== UI BINDINGS ============== */
function resize(){
  // maintain aspect ratio of offscreen buffer, fill window
  const w = window.innerWidth, h = window.innerHeight;
  const ar = off.width / off.height;
  let vw = w, vh = Math.floor(w / ar);
  if (vh > h){ vh = h; vw = Math.floor(h * ar); }
  canvas.width = vw; canvas.height = vh;
}
window.addEventListener('resize', resize);

function setModeLabels(){
  const hudMode = document.getElementById('hudMode');
  const lapLabel = document.getElementById('hudLapLabel');
  if (mode==='laps'){ hudMode.textContent = '3 Laps'; lapLabel.textContent = 'Lap'; }
  else { hudMode.textContent = '60s Time Trial'; lapLabel.textContent = 'Lap'; }
}

/* Buttons */
function bindButton(el, onDown, onUp){
  const prevent = (e)=>{ e.preventDefault(); e.stopPropagation(); };
  el.addEventListener('touchstart', (e)=>{ prevent(e); onDown(); }, {passive:false});
  el.addEventListener('touchend',   (e)=>{ prevent(e); onUp(); }, {passive:false});
  el.addEventListener('mousedown',  (e)=>{ prevent(e); onDown(); });
  el.addEventListener('mouseup',    (e)=>{ prevent(e); onUp(); });
  el.addEventListener('mouseleave', (e)=>{ onUp(); });
}

/* On-screen controls */
bindButton(document.getElementById('btnBrake'),
  ()=>{ mobileHold.brake=true; input.brake=true; },
  ()=>{ mobileHold.brake=false; input.brake=false; });

bindButton(document.getElementById('btnJump'),
  ()=>{ mobileHold.jump=true; input.jump=true; setTimeout(()=>{ input.jump=false; }, 50); },
  ()=>{ mobileHold.jump=false; });

bindButton(document.getElementById('btnBoost'),
  ()=>{ mobileHold.boost=true; input.boost=true; },
  ()=>{ mobileHold.boost=false; input.boost=false; });

/* Pause and Mute */
document.getElementById('btnPause').addEventListener('click', ()=>{
  if (gameState==='running'){ gameState='paused'; document.getElementById('btnPause').textContent='Resume'; }
  else if (gameState==='paused'){ gameState='running'; document.getElementById('btnPause').textContent='Pause'; AudioSys.ensure(); }
});
document.getElementById('btnMute').addEventListener('click', ()=>{
  muted = !muted;
  document.getElementById('btnMute').classList.toggle('muted', muted);
  if (!muted) AudioSys.ensure();
});

/* Keyboard */
window.addEventListener('keydown', (e)=>{
  if (gameState==='menu') return;
  if (e.repeat) return;
  switch(e.code){
    case 'KeyA': case 'ArrowLeft': input.brake=true; break;
    case 'Space': input.jump=true; break;
    case 'ShiftLeft': case 'ShiftRight': input.boost=true; break;
    case 'KeyR': restart(); break;
    case 'KeyP': case 'Escape':
      if (gameState==='running'){ gameState='paused'; document.getElementById('btnPause').textContent='Resume'; }
      else if (gameState==='paused'){ gameState='running'; document.getElementById('btnPause').textContent='Pause'; }
      break;
    case 'KeyM': muted=!muted; document.getElementById('btnMute').classList.toggle('muted', muted); break;
  }
});
window.addEventListener('keyup', (e)=>{
  switch(e.code){
    case 'KeyA': case 'ArrowLeft': input.brake=false; break;
    case 'Space': input.jump=false; break;
    case 'ShiftLeft': case 'ShiftRight': input.boost=false; break;
  }
});

/* Start screen: truck cards */
function drawTruckThumbnail(type, size=96){
  const c = document.createElement('canvas');
  c.width = size; c.height = size; const g = c.getContext('2d'); g.imageSmoothingEnabled = false;
  // simple miniature render
  g.fillStyle = '#22303a'; g.fillRect(0,0,size,size);
  const x = size/2, y = size/2 + 8;
  // wheels
  function w(cx,cy,r){ g.fillStyle = '#111'; g.beginPath(); g.arc(cx,cy,r,0,Math.PI*2); g.fill();
                       g.fillStyle='#555'; g.beginPath(); g.arc(cx,cy,r*0.35,0,Math.PI*2); g.fill(); }
  w(x-18,y, size*0.14); w(x+18,y, size*0.14);
  g.fillStyle = '#222'; g.fillRect(x-22,y-10,44,6);
  g.fillStyle = type.color;
  if (type.id==='lambo'){ g.fillRect(x-20,y-22,40,12); g.fillStyle='#333'; g.fillRect(x-6,y-26,14,6); }
  else if (type.id==='offroad'){ g.fillRect(x-24,y-20,36,12); g.fillRect(x+8,y-18,14,10); g.fillStyle='#ffe066'; for(let i=-12;i<=4;i+=8) g.fillRect(x+i,y-24,4,4); }
  else { g.fillRect(x-22,y-20,44,10); g.fillStyle='#1a9b56'; g.fillRect(x-6,y-24,16,6); g.fillStyle=type.color; g.fillRect(x+14,y-22,8,2); }
  return c;
}

function buildTruckGrid(){
  const grid = document.getElementById('truckGrid');
  trucks.forEach((t, idx)=>{
    const div = document.createElement('div');
    div.className = 'truck';
    const thumb = drawTruckThumbnail(t, 96);
    div.appendChild(thumb);
    const name = document.createElement('div');
    name.textContent = t.name;
    name.style.marginTop = '6px'; name.style.fontSize='12px';
    div.appendChild(name);
    if (idx===0) { div.classList.add('selected'); }
    div.addEventListener('click', ()=>{
      document.querySelectorAll('.truck').forEach(el=>el.classList.remove('selected'));
      div.classList.add('selected');
      selectedTruck = t;
    });
    grid.appendChild(div);
  });
}

document.querySelectorAll('input[name="mode"]').forEach(r=>{
  r.addEventListener('change', e=>{
    mode = e.target.value==='time' ? 'time' : 'laps';
    setModeLabels();
  });
});

document.getElementById('btnStart').addEventListener('click', ()=>{
  document.getElementById('startScreen').style.display='none';
  gameState='running';
  AudioSys.ensure();
  setModeLabels();
});

document.getElementById('btnRestart').addEventListener('click', ()=>{
  restart();
});

function restart(){
  document.getElementById('finishScreen').style.display='none';
  world.seed = Math.floor(Math.random()*100000)|0;
  placeWorld(world.seed);
  resetPlayer();
  gameState='running';
  document.getElementById('btnPause').textContent='Pause';
  setModeLabels();
}

/* Finish */
function finishRun(){
  gameState='finished';
  const fin = document.getElementById('finishScreen');
  const title = document.getElementById('finishTitle');
  const stats = document.getElementById('finishStats');
  const pb = document.getElementById('finishPB');
  fin.style.display='grid';

  title.textContent = 'Great job, Brent!';
  stats.innerHTML = `Mode: <b>${mode==='laps'?'3 Laps':'60s Time Trial'}</b><br>
                     Time: <b>${formatTime(player.time)}</b> &nbsp; Coins: <b>${player.coins}</b>`;

  // PB handling
  const pbData = loadPB(selectedTruck.id);
  if (mode==='laps'){
    let improved = false;
    if (pbData.bestTimeLaps==null || player.time < pbData.bestTimeLaps){ pbData.bestTimeLaps = player.time; improved = true; }
    if (player.coins > pbData.bestCoinsLaps){ pbData.bestCoinsLaps = player.coins; improved = true; }
    savePB(selectedTruck.id, pbData);
    pb.innerHTML = `Best time: <b>${pbData.bestTimeLaps?formatTime(pbData.bestTimeLaps):'—'}</b> &nbsp; Best coins: <b>${pbData.bestCoinsLaps}</b> ${improved?' <span style="color:#0f0;">(new!)</span>':''}`;
  } else {
    let improved = false;
    if (player.coins > pbData.bestCoinsTime){ pbData.bestCoinsTime = player.coins; improved = true; }
    savePB(selectedTruck.id, pbData);
    pb.innerHTML = `Best coins in 60s: <b>${pbData.bestCoinsTime}</b> ${improved?' <span style="color:#0f0;">(new!)</span>':''}`;
  }
}

/* ============== INIT ============== */
function init(){
  buildTruckGrid();
  placeWorld(world.seed);
  resetPlayer();
  resize();
  requestAnimationFrame(loop);
}
init();

</script>
</body>
</html>
